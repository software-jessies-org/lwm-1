2018-12-08 (pn) Done a bit of clean-up in here. I've also set up a bunch of
sections, generally from most to least important. At the top we have crashes,
and at the bottom clean-ups.

Right at the bottom of the file there's a cheat sheet of debugging tools.


=== CRASHES ===


=== FUNCTIONAL BREAKAGES ===

There's a race condition in focus-follows-mouse where if the user tries to
move the mouse from window A to B, which passes across window C, which
covers a small gap between A and B, focus is given to C, despite the fact
that the pointer last enters B. This only seems to happen for me on linux,
not on FreeBSD.

There's a 1 pixel area around the edge of the window which is always a move
widget. I think it's the window border. It should be a resize widget though.
This is a failure in how the bounding boxes for the edges is calculated.

ImageMagick's "display" program doesn't work well *at all* with LWM - it has a
tendency to open the main window far too large, and then make it disappear when
anything is done to it. My current guess is that this has something to do with
its use of 'group leader' windows, and possibly also due to the specification
that if a window manager tries to impose an unacceptable size, a client should
respond by iconifying itself. LWM may be mishandling the size constraints of
the display program.

I believe LWM isn't properly extracting struts on start-up; several times I've
had to pkill -HUP menu, after which its struts reappear. Not sure precisely why.


=== THINGS THAT LOOK SILLY ===


=== ERROR LOGS ===

LWM produces error messages like these:
lwm: protocol request X_ConfigureWindow on resource 0x1200001 failed: BadMatch (invalid parameter attributes)
lwm: protocol request X_ConfigureWindow on resource 0x1800001 failed: BadMatch (invalid parameter attributes)
lwm: protocol request X_ConfigureWindow on resource 0x1a00001 failed: BadMatch (invalid parameter attributes)
lwm: protocol request X_ConfigureWindow on resource 0x1c00001 failed: BadMatch (invalid parameter attributes)


=== FEATURES ===

Detect when mouse pointer switches between displays (for multiple xrandr
monitors) and bring up some visual indication of where the pointer has gone.

Make the size of the mouse pointer configurable. Some people have poor vision,
and would benefit from a larger pointer (and 4k displays exacerbate this).

Have some mechanism for the user adding a human-defined prefix to a window's
title. Or possibly an alternative name (or prefix) for when the window is shown
in the unhide menu. Basically, some nice way to quickly identify the window.

Maybe implement keyboard control? Grabbing the 'Menu' key, for example, might be
a reasonable thing to do (although probably best to specify the key to grab as
an Xresource, and let the user define it). This could be used to open the unhide
menu where the mouse is, warp the pointer to the middle of the menu item which
currently has focus, and then (as the pointer is over the menu) take control of
the arrow keys to navigate up and down the menu, using pointer-warping. Hitting
Return would do the normal unhide action on the selected window, and warp the
pointer to its middle.


=== CLEANUPS ===

The way we deal with window sizes seems rather odd. The 'size' variable in a
Client is actually the client window size, plus the width of LWM's frame on all
sides, *BUT* excluding the title bar! I vaguely remember something about an old
version of LWM where a title bar was only shown on the focused window; maybe
it's from way back then. Anyway, the way sizes are manipulated is unclear,
badly-indicated in code/comments, and inconsistent. I'm not at all confident
it's correct in all cases.


=== DEBUGGING TOOLS ===

To get a dump of the window tree:
xwininfo -root -tree

To print details about a window:
xprop -id <id>

Test LWM changes in a VNC session (I use tightvnc). Believe me, testing LWM in
the same X session as you're using to edit its code is a seriously painful
experience.
vncserver -geometry 1600x1200 -name test
vncviewer localhost:1

In this directory there's a file called 'xdbg.cc', which can be compiled and
run. It shows a window which displays the mouse coordinates, and its last
configure request coordinates. Also, if you press and hold the shift key, it
will measure the mouse coordinates from when you press down shift until when you
release it, and on release also prints the start, end and distance to stdout.
This is very useful for comparing coordinates, and checking window positioning.


UNIT TESTS
~~~~~~~~~~
LWM has built-in unit tests. Welcome to modernity! They're all in 'tests.cc',
and are built into the main LWM binary. To run:
 ./lwm -test

I know building tests directly into the main binary isn't best practice, but
making LWM properly unit-testable would involve splitting up lwm.h and the
inevitable refactoring that'd require, plus bashing my head against Makefile.
Neither of these is appealing right now. The size of the unit test module is
not going to incur a serious drain on memory.

After all, we already have a built-in debug CLI; why not add a test suite? :-)


=== MY FAVOURITE DEBUGGING ENVIRONMENT ===

# Three terminals. In one, I do:
vncserver -geometry 1600x1200 -name test
vncviewer localhost:1
# Then, after login, ctrl-z and bg to background the vncviewer.
cd $HOME/dev/lwm
DISPLAY=:1 ./lwm -debugcli="xrandr 800x1200+0+0 800x500+800+0;dbg auto" 2>$HOME/stderr

# Second terminal:
tail -f $HOME/stderr

# Third terminal, used for rebuilding LWM:
cd $HOME/dev/lwm
make -j20
# Or, if I'm feeling really experimental, I might do:
while sleep 1; do make -j20; done
# ...which auto-rebuilds LWM every time I save a file.


DEBUG CLI
~~~~~~~~~
LWM can be run with the -debugcli command to have it listen for commands on
stdin. It doesn't have advanced editing functions, it's just a plain stdin
pipe which reads a line at a time. If you want editing functions, edit the lines
you want to paste in an editor.

It is recommended to redirect stderr into a file, and 'tail -f' it in a separate
terminal from the one in which the debug CLI is running. That way, your
interaction with the embedded debugger doesn't interfere with the debug logs,
and vice versa.

If -debugcli is specified with an argument, the argument is a sequence of
commands to run at start-up. This can be useful if you repeatedly want to set
auto-debug of new clients, or some other stuff.

For example, to print help on start-up, run:
./lwm -debugcli=help

To start up with xrandr faking on, and with an inaccessible area on the bottom-
right of the screen, and auto-debug of new clients, and with stderr going to a
file called 'stderr' in your home dir:
./lwm -debugcli="xrandr 800x1200+0+0 800x500+800+0;dbg auto" 2>$HOME/stderr

In another terminal, do:
tail -f $HOME/stderr

This keeps stdout/stderr separate (so interactions with the debug cli separate
from debugging output).

Available commands are:

help   - print out help.
ls     - lists the active clients.
dbg    - control over per-client debug messages (type 'dbg help' for details).
xrandr - test xrandr handling without fiddling with cables.

TODO: move the following xrandr help into the debug code.
TODO: refactor the debug handlers so there's a nice simple structure, and the
      help handling has a bit more structure.

xrandr (test xrandr handling without fiddling with cables)
~~~~~~
xrandr ?                         Print current visible areas.
xrandr                           Set visible area to be the full screen.
xrandr 100x200+0+0 100x50+100+0  Set visible areas.
